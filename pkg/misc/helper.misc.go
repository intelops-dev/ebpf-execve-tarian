/**
*	Type: package
*	Name: json
*	Description: This package holds helper functions used by
*                exported misc functions. This functions are not
*                visible outside of this package.
*
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-20-2023
 */
package misc

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"os"
	"reflect"
	"strings"
	"tarian/pkg/time"
)

/**
*	Type: function
*	Name: must
*	Params:
*		- Name: msg
*		  Type: string
*		  Description: message to print on screen before panicking.
*		- Name: err
*		  Type: error
*		  Description: error
* 	Description: prints the message on the screen if there was a
*                error and panics.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-12-2023
 */
func must(msg string, err error) {
	if err != nil {
		fmt.Printf("\n%s: %v\n", msg, err)
		os.Exit(1)
	}
}

/**
*	Type: function
*	Name: printMap
*	Params:
*		- Name: mp
*		  Type: map
*		  Description: expected map of key type string.
*
* 	Description: prints maps key and values to standard output.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-20-2023
 */
func printMap(mp map[string]interface{}, divide bool) {
	if divide {
		divider("-", 50)
	}

	for ky, vl := range mp {
		if isMap(vl) {
			if subMap, ok := vl.(map[string]interface{}); ok {
				printMap(subMap, false)
			}
		} else {
			fmt.Printf("%s: %v\n", ky, vl)
		}
	}

	if divide {
		divider("-", 50)
	}
}

/**
*	Type: function
*	Name: divider
*	Params:
*		- Name: sym
*		  Type: string
*		  Description: symbol to print to stdout
*		- Name: rep
*		  Type: int
*		  Description: number of times the symbol should repeat.
*
* 	Description: prints symbol to standard output rep times.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-12-2023
 */
func divider(sym string, rep int) {
	sym = strings.Repeat(sym, rep)

	fmt.Println(sym)
}

/**
*	Type: function
*	Name: formatString
*	Params:
*		- Name: format
*		  Type: string
*		  Description: string format
*		- Name: args
*		  Type: any
*		  Variadic: true
*	returns: string
* 	Description: format the string and returns the resultant string.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-12-2023
 */
func formatString(format string, args ...interface{}) string {
	return fmt.Sprintf(format, args...)
}

/**
*	Type: function
*	Name: toString
*	Params:
*		- Name: data
*		  Type: any
*		  Description:
*	Returns: string
* 	Description: convert given info to string using fmt.Sprintf
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-19-2023
 */
func toString(data interface{}) string {
	str := fmt.Sprintf("%s", data)

	return str
}

/**
*	Type: function
*	Name: prettyBytes
*	Params:
*		- Name: buf
*		  Type: []byte
*		  Description:
*		- Name: data
*		  Type: any
*		  Description:
* 	Description: returns the bytes in readable format.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-18-2023
 */
func prettyBytes(buf []byte, data interface{}) error {
	err := binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, data)
	if err != nil {
		return err
	}

	return nil
}

/**
*	Type: function
*	Name: removeNullBytes
*	Params:
*		- Name: arr
*		  Type: []uint8
*		  Description: source
* 	Description: removes the null bytes from the array and returns the array.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-17-2023
 */
func removeNullBytes(arr []uint8) []uint8 {
	idx := indexOf(arr, 0)
	return arr[:idx]
}

/**
*	Type: function
*	Name: structToMap
*	Params:
*		- Name: data
*		  Type: any
*		  Description:
* 	Description: converts struct to map. It also appends __Id field.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-13-2023
*	Last Modified: 04-20-2023
 */
func structToMap(data interface{}) map[string]interface{} {
	dataMap := map[string]interface{}{}

	typeData := reflect.TypeOf(data)
	valueData := reflect.ValueOf(data)

	for i := 0; i < valueData.NumField(); i++ {
		if !typeData.Field(i).IsExported() {
			continue
		}

		currFieldType := typeData.Field(i).Type
		currFieldName := typeData.Field(i).Name
		currFieldValue := valueData.Field(i)

		switch currFieldType.Kind().String() {
		case "array":
			switch currFieldType.Elem().Kind().String() {
			case "array":
				{
					switch currFieldValue.Type().Elem().Elem().Kind().String() {
					case "uint8":
						var str string
						for j := 0; j < currFieldValue.Len(); j++ {
							currStr := uint8ToString(toUint8Slice(currFieldValue.Index(j)))
							if len(currStr) > 0 {
								if len(str) != 0 {
									str += " " + currStr
								} else {
									str = currStr
								}
							}
						}

						dataMap[currFieldName] = str

					default:
						dataMap[currFieldName] = toString(currFieldValue)
					}
				}
			case "uint8":
				{
					currVal := toUint8Slice(currFieldValue)

					dataMap[currFieldName] = uint8ToString(currVal)
				}
			}
		case "uint16", "uint32", "uint64":
			dataMap[currFieldName] = currFieldValue.Uint()

		case "int16", "int32", "int64":
			dataMap[currFieldName] = currFieldValue.Int()

		default:
			{
				dataMap[currFieldName] = currFieldValue
			}
		}
	}

	dataMap["__Id"] = time.GetTimestamp()
	return dataMap
}

/**
*	Type: function
*	Name: indexOf
*	Params:
*		- Name: arr
*		  Type: []uint8
*		  Description: source
*		- Name: val
*		  Type: uint8
*		  Description: element to remove
*	Returns: int
* 	Description: matches the val with element of arr and returns its index. If not found returns -1
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-17-2023
*	Last Modified: 04-17-2023
 */
func indexOf(arr []uint8, val uint8) int {
	for idx, ele := range arr {
		if ele == val {
			return idx
		}
	}

	return -1
}

/**
*	Type: function
*	Name: uint8ToString
*	Params:
*		- Name: arr
*		  Type: []uint8
*		  Description: source
*	Returns: string
* 	Description: converts the given uint8 array to string. If there are null bytes it removes them.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-17-2023
*	Last Modified: 04-17-2023
 */
func uint8ToString(arr []uint8) string {
	arr = removeNullBytes(arr)

	return toString(arr)
}

/**
*	Type: function
*	Name: toUint8Slice
*	Params:
*		- Name: arr
*		  Type: reflect,Value
*		  Description: source
*	Returns: [] uint8
* 	Description: converts the reflect.Value to uint8 slice. panics if value id not of type uint8 array or slice.
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-12-2023
*	Last Modified: 04-17-2023
 */
func toUint8Slice(arr reflect.Value) []uint8 {
	if arr.Type().Elem().Kind() != reflect.Uint8 {
		panic("Type mismacth: Expected []uint8 array or slice")
	}

	slice := reflect.MakeSlice(reflect.SliceOf(reflect.TypeOf(uint8(0))), arr.Len(), arr.Len())
	reflect.Copy(slice, arr)

	return slice.Bytes()
}

/**
*	Type: function
*	Name: spreadMap
*	Params:
*		- Name: src
*		  Type: map[string]interface{}
*		  Description:
*		- Name: dest
*		  Type: map[string]interface{}
*		  Description:
* 	Description:
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-20-2023
*	Last Modified: 04-20-2023
 */
func spreadMap(src map[string]interface{}, dest map[string]interface{}) {
	for key, val := range src {
		dest[key] = val
	}
}

/**
*	Type: function
*	Name: isMap
*	Params:
*		- Name: value
*		  Type: interface{}
*		  Description:
* 	Description:
*
*	returns: bool
*
*	Exported: false
*
*	Authors: Charan Ravela
*	Created On: 04-20-2023
*	Last Modified: 04-20-2023
 */
func isMap(value interface{}) bool {
	return reflect.TypeOf(value).Kind() == reflect.Map
}

/**
*	Type: package
*	Name: exit
*	Description: This is a user space program. returns the events caputred by sys_enter_execve hook
*d
*
*	Authors: Charan Ravela
*	Created Date: 04-20-2023
*	Last Modified: 04-20-2023
 */

package process_exit

import (
	"os"
	"tarian/pkg/ebpf"
	"tarian/pkg/misc"
	"tarian/pkg/time"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -cflags $BPF_CFLAGS -type event_data exit exit.bpf.c -- -I../../../headers

/**
* HookType: Tracepoint
* Hook: sys_exit_execve
* MapType: Ring buffer
 */

var hook map[string]interface{} = map[string]interface{}{
	"group": "syscalls",
	"name":  "sys_exit_execve",
}

var info map[string]interface{} = map[string]interface{}{
	"start_time": time.Now(),
	"hook":       hook,
}

type Event struct {
	group     string //hook group
	hook_name string // hook name
	info      map[string]interface{}

	BpfObj       exitObjects     //holds bpf maps and program
	BpfHook      link.Link       //holds bpf hook
	BpfMapReader *ringbuf.Reader //map data reader

	prettyDataChan chan *map[string]interface{} //used to emit beautified data
	rawDataChan    chan []byte                  //used to emit raw data from kernel
	stopperChan    chan os.Signal               //used to signal program termination

	ShouldTerminate bool //stop the program execution if true
}

func NewProcessExit(comChan ebpf.ComChan) (*Event, error) {
	evt := &Event{
		group:     hook["group"].(string),
		hook_name: hook["name"].(string),
		info:      info,

		prettyDataChan: comChan.DataChan,
		rawDataChan:    make(chan []byte),
		stopperChan:    comChan.StopperChan,

		ShouldTerminate: false,
	}

	err := evt.load()
	if err != nil {
		return nil, err
	}

	return evt, nil
}

func (evt *Event) load() error {
	var err error

	err = rlimit.RemoveMemlock()
	if err != nil {
		return err
	}

	err = loadExitObjects(&evt.BpfObj, nil)
	if err != nil {
		return err
	}

	evt.BpfHook, err = link.Tracepoint(evt.group, evt.hook_name, evt.BpfObj.ExecveExit, nil)
	if err != nil {
		return err
	}

	evt.BpfMapReader, err = ringbuf.NewReader(evt.BpfObj.Event)
	if err != nil {
		return err
	}

	return nil
}

func (evt *Event) Emit() {
	for {
		if evt.ShouldTerminate {
			break
		}

		record, err := evt.BpfMapReader.Read()
		if err != nil {
			continue
		}

		evt.rawDataChan <- record.RawSample
	}
}

func (evt *Event) Receive() {
	for {
		if evt.ShouldTerminate {
			break
		}

		rawDt := <-evt.rawDataChan

		var pd exitEventData
		err := misc.PrettyBytes(rawDt, &pd)
		if err != nil {
			continue
		}

		evt.info["data"] = misc.StructToMap(pd)
		evt.prettyDataChan <- &evt.info
	}
}

func (evt *Event) Stop() {
	evt.BpfObj.Close()
	evt.BpfMapReader.Close()
	evt.BpfHook.Close()
	evt.ShouldTerminate = true
}

package ebpf

import (
	"tarian/pkg/misc"
	"tarian/pkg/time"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
)

func (ep *EbpfProgram) attachHook() (link.Link, error) {
	var hook link.Link
	var err error

	switch ep.BpfHook.Type {
	case "tracepoint":
		hook, err = link.Tracepoint(ep.BpfHook.Group, ep.BpfHook.Name, ep.BpfProgram, nil)
	case "xdp":
		hook, err = link.AttachXDP(ep.BpfHook.XdpOpts)
	}

	if err != nil {
		return nil, err
	}

	return hook, nil
}

func (ep *EbpfProgram) mapReader() (*ringbuf.Reader, error) {
	BpfMapReader, err := ringbuf.NewReader(ep.BpfMap)
	if err != nil {
		return nil, err
	}

	return BpfMapReader, nil
}

func (ep *EbpfProgram) newEbpf(comm Communication) (*EbpfHandlers, error) {
	var err error
	eh := &EbpfHandlers{
		Comm: comm,
	}
	eh.data_type = ep.DataType
	eh.evt.Start_time = time.Now()
	eh.evt.Hook = ep.BpfHook

	eh.Link, err = ep.attachHook()
	if err != nil {
		return nil, err
	}

	eh.MapReader, err = ep.mapReader()
	if err != nil {
		return nil, err
	}

	return eh, nil
}

func (eh *EbpfHandlers) emit() {
	for {
		if eh.ShouldTerminate {
			break
		}

		record, err := eh.MapReader.Read()
		if err != nil {
			continue
		}

		misc.PrettyBytes(record.RawSample, eh.data_type)
		eh.evt.Data = &eh.data_type
		eh.Comm.DataChan <- &eh.evt
	}
}

// func (eh *EbpfHandlers) sanitize() {
// 	for {
// 		if eh.ShouldTerminate {
// 			break
// 		}

// 		rawDt := <-eh.Comm.rawData
// 		err := misc.PrettyBytes(*rawDt, &eh.data_type)
// 		if err != nil {
// 			continue
// 		}

// 		eh.evt.Data = eh.data_type
// 		eh.Comm.DataChan <- &eh.evt
// 	}
// }

func (eh *EbpfHandlers) close() {
	eh.ShouldTerminate = true

	if eh.Link != nil {
		eh.Link.Close()
	}

	if eh.MapReader != nil {
		eh.MapReader.Close()
	}
}

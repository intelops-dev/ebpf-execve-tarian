package main

import (
	"os"
	"os/signal"
	"syscall"
	"tarian/pkg/ebpf"
	"tarian/pkg/ebpf/process_entry"
	"tarian/pkg/ebpf/process_exit"
	"tarian/pkg/file"
	"tarian/pkg/json"
	"tarian/pkg/misc"
	"tarian/pkg/progress"
	"tarian/pkg/time"
)

type ProgramData struct {
	FileCount  int
	CurrCount  int
	TotalCount int
	TotalSize  float64

	Cache []interface{}
}

type ComChan struct {
	StopperChan chan os.Signal
	DataChan    chan *map[string]interface{}
}

func main() {
	pd := &ProgramData{}

	root, _ := os.Getwd()
	directory := root + "/output/" + time.Now("Mon_Jan _2 2006 MST")
	file.MkDirAll(directory)

	currPd := ebpf.ComChan{
		StopperChan: make(chan os.Signal),
		DataChan:    make(chan *map[string]interface{}),
	}

	evt, err := process_exit.NewProcessExit(currPd)
	misc.Must("Error while loading ebpf programs", err)

	evt1, err := process_entry.NewProcessEntry(currPd)
	misc.Must("Error while loading ebpf programs", err)

	go evt.Emit()
	go evt.Receive()

	go evt1.Emit()
	go evt1.Receive()

	ticker := time.Ticker(5)
	go func() { signal.Notify(currPd.StopperChan, os.Interrupt, syscall.SIGTERM, syscall.SIGINT) }()

	for {
		select {
		case v := <-currPd.DataChan:
			pd.Cache = append(pd.Cache, *v)
			pd.CurrCount++
			pd.TotalCount++
		case <-ticker.C:
			if pd.CurrCount > 0 {
				pd.export(directory)
			}
		case <-currPd.StopperChan:
			if pd.CurrCount > 0 {
				pd.export(directory)
			}

			progress.Basic("Total %d records caputured. Wrote to %d json files of size %f MB at path \n\n%s.\n", pd.TotalCount, pd.FileCount, pd.TotalSize/(1024*1024), directory)
			evt.ShouldTerminate = true
			evt.Stop()
		}

		progress.Basic("Captured %d records. Wrote %d JSON files. Size of the data exported %f MB.", pd.TotalCount, pd.FileCount, pd.TotalSize/(1024*1024))

		if evt.ShouldTerminate || evt1.ShouldTerminate {
			break
		}
	}
}

func (pd *ProgramData) export(directory string) {
	fnm := directory + "/" + filename(pd.CurrCount, pd.FileCount) + ".json"

	fptr := file.CreateFile(fnm)
	json.WriteJson(fptr, pd.Cache)

	pd.Cache = []interface{}{}
	pd.CurrCount = 0
	pd.FileCount++
	pd.TotalSize += float64(file.Size(fnm))
}

func filename(rc int, fc int) string {
	return misc.FormatString("%s_%d_%d", time.Now("15 04 05"), fc, rc)
}

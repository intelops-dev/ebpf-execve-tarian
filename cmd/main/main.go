package main

import (
	"os"
	"os/signal"
	"syscall"
	"tarian/pkg/ebpf"
	"tarian/pkg/file"
	"tarian/pkg/json"
	"tarian/pkg/misc"
	"tarian/pkg/progress"
	"tarian/pkg/time"

	"tarian/pkg/modules"
)

type ProgramData struct {
	FileCount  int
	CurrCount  int
	TotalCount int
	TotalSize  float64

	Cache []interface{}
}

func main() {
	var should_stop bool
	pd := &ProgramData{}

	root, _ := os.Getwd()
	directory := root + "/output/" + time.Now("Mon_Jan _2 2006 MST")
	file.MkDirAll(directory)

	currPd := ebpf.Communication{
		StopperChan: make(chan os.Signal),
		DataChan:    make(chan *ebpf.Event),
	}

	ebpfs := modules.NewEbpf(currPd)
	start(ebpfs)

	ticker := time.Ticker(5)
	go func() { signal.Notify(currPd.StopperChan, os.Interrupt, syscall.SIGTERM, syscall.SIGINT) }()

	for {
		select {
		case v := <-currPd.DataChan:
			pd.Cache = append(pd.Cache, *v)
			pd.CurrCount++
			pd.TotalCount++
		case <-ticker.C:
			if pd.CurrCount > 0 {
				pd.export(directory)
			}
		case <-currPd.StopperChan:
			if pd.CurrCount > 0 {
				pd.export(directory)
			}

			progress.Basic("Total %d records caputured. Wrote to %d json files of size %f MB at path \n\n%s.\n", pd.TotalCount, pd.FileCount, pd.TotalSize/(1024*1024), directory)
			stop(ebpfs)
			should_stop = true
		}

		progress.Basic("Captured %d records. Wrote %d JSON files. Size of the data exported %f MB.", pd.TotalCount, pd.FileCount, pd.TotalSize/(1024*1024))

		if should_stop {
			break
		}
	}
}

func (pd *ProgramData) export(directory string) {
	fnm := directory + "/" + filename(pd.CurrCount, pd.FileCount) + ".json"

	fptr := file.CreateFile(fnm)
	json.WriteJson(fptr, pd.Cache)

	pd.Cache = []interface{}{}
	pd.CurrCount = 0
	pd.FileCount++
	pd.TotalSize += float64(file.Size(fnm))
}

func filename(rc int, fc int) string {
	return misc.FormatString("%s_%d_%d", time.Now("15 04 05"), fc, rc)
}

func start(ebpfs []*ebpf.EbpfHandlers) {
	for _, ebpf := range ebpfs {
		ebpf.Start()
	}
}

func stop(ebpfs []*ebpf.EbpfHandlers) {
	for _, ebpf := range ebpfs {
		ebpf.Stop()
	}
}

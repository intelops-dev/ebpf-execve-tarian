//go:build ignore

/**
*	Type: package
*	Name: main
*	Description: This is a kernel space program. It attaches to tracepoint event.
*
*
*	Authors: Charan Ravela
*	Created Date: 04-11-2023
*	Last Modified: 04-18-2023
 */

#include "vmlinux.h"
#include "bpf_helpers.h"

// struct user_comm{
//     long len;
//     __u8 comm[256];
// };

struct event_data
{
    __u32 pid;
    __u32 tgid;
    __u32 uid;
    __u32 gid;
    __s32 syscall_nr;
    __u8 comm[16];
    __u8 cwd[32];
    __u8 binary_filepath[256];
    __u8 user_comm[256][256];
};
const struct event_data *unused __attribute__((unused));

struct{
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 1 << 24);
} event SEC(".maps");

static char zero[256] SEC(".rodata") = {0};

//sys_enter_execve data structure
//can be found at below path
// /sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format
struct execve_struct
{
    __u16 common_type;
    __u8 common_flags;
    __u8 common_preempt_count;
    __s32 common_pid;

    __s32 syscall_nr;
    __u8 const *filename;
    __u8 *const argv;
    __u8 *const envp;
};

SEC("tracepoint/syscalls/sys_enter_execve")
int ebpf_execve(struct execve_struct *ctx){
    struct event_data *ed;
    s64 read_len;
    ed = bpf_ringbuf_reserve(&event, sizeof(struct event_data), 0);
    if (!ed) {
        return 0;
    }
    ed->syscall_nr = ctx->syscall_nr;

    //fetches user command binary filepath    
    read_len = bpf_probe_read_user_str(&ed->binary_filepath, sizeof(ed->binary_filepath), ctx->filename);
    if(read_len < 0){
        bpf_printk("Not able to read binary name: %d", read_len);
    }

    // fetch current command
    bpf_get_current_comm(&ed->comm, sizeof(ed->comm));

    //fetch process id and thread group id
    __u64 pid_tgid = bpf_get_current_pid_tgid();  
    ed->pid = pid_tgid >> 32;
    ed->tgid = pid_tgid;

    //fetch user id and group id
    __u64 uid_gid = bpf_get_current_uid_gid();
    ed->uid = uid_gid >> 32;
    ed->gid = uid_gid;

    //fetches current working directory
    struct task_struct *task = (struct task_struct *)bpf_get_current_task();
    struct fs_struct *fs;
    struct dentry *dentry;

    bpf_probe_read_kernel(&fs, sizeof(fs), &task->fs);
    bpf_probe_read_kernel(&dentry, sizeof(dentry), &fs->pwd.dentry);
    bpf_probe_read_kernel(&ed->cwd, sizeof(ed->cwd), &dentry->d_iname);

    //fetches the user command
    __u8 *filn;
    int i = 0;
    while (i <= 255){
        bpf_probe_read(&filn, sizeof(filn), &ctx->argv[i]);
        if(filn == NULL){
            break;
        }

        bpf_probe_read_kernel_str(&ed->user_comm[i], sizeof(ed->user_comm[i]), &zero);
        read_len = bpf_probe_read_user_str(&ed->user_comm[i], sizeof(ed->user_comm[i]), filn);


        i++;
    };

    //pushes the information to ringbuf event map
    bpf_ringbuf_submit(ed, 0);

    return 0;
};

char _license[] SEC("license") = "Dual MIT/GPL";
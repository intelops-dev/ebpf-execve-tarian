/**
*	Type: package
*	Name: main
*	Description: This is a user space program. loads ebpf program and attaches it to the kernel events.
*
*
*	Authors: Charan Ravela
*	Created Date: 04-11-2023
*	Last Modified: 04-18-2023
 */

package main

import (
	"C"
	"os"
	"tarian/pkg/misc"
	"tarian/pkg/time"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)
import (
	"fmt"
	"os/signal"
	"syscall"
	"tarian/pkg/file"
	"tarian/pkg/json"
	"tarian/pkg/progress"
)

type Limits struct {
	TimeLimit   int //holds the time frequency to export data in miliseconds
	RecordCount int //holds the record count to export data.
}

type ProgramData struct {
	StartTime string //holds start time of the program
	EndTime   string //holds the end time of the program

	FileCount  int
	CurrCount  int     //holds the count of the records ready for exporitng
	TotalCount int     //hold the count for totalt records captured
	TotalSize  float64 //holds the size of the data exported

	Cache []map[string]interface{} //holds the records which were not exported

	BpfObj       bpfObjects      //holds bpf elements
	BpfHook      link.Link       //holds bpf hook
	BpfMapReader *ringbuf.Reader //map reader

	Timer *time.Tick //emits the for every n frequency used to export data

	EventDataChan      chan *bpfEventData // holds readable kernel information
	MapDataEmitterChan chan []byte        //emits the kernel code output
	stopperChan        chan os.Signal     //used for prorgam termination

	ShouldTerminate bool //terminates the program
}

/**
*	Type: command
*	Description: This command is responsible for compling the ebpf c code and generate *_bpfeb.* and *_bpfel.* files
 */
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -cflags $BPF_CFLAGS -type event_data bpf index.bpf.c -- -I../../headers

func main() {
	limits := &Limits{}
	limits.defaultLimits()

	progEvt, err := NewEbpf()
	misc.Must("Error while loading ebpf objects", err)
	progEvt.StartTime = time.Now()
	progEvt.stopperChan = make(chan os.Signal, 1)

	root, _ := os.Getwd()
	directory := root + "/output/" + time.Now("Mon_Jan _2 2006 MST")
	file.MkDirAll(directory)

	go progEvt.MapStart()
	go progEvt.Start()
	progEvt.Timer = time.Ticker(limits.TimeLimit)
	go func() { signal.Notify(progEvt.stopperChan, os.Interrupt, syscall.SIGTERM, syscall.SIGINT) }()

	fmt.Println()
	var fnm string
	for {
		select {
		case record := <-progEvt.EventDataChan:
			currRec := misc.StructToMap(*record)
			progEvt.Cache = append(progEvt.Cache, currRec)
			progEvt.TotalCount++
			progEvt.CurrCount++
			// misc.PrintMap(currRec)

		case <-progEvt.Timer.C:
			if progEvt.CurrCount > 0 {
				fnm = directory + "/" + filename(progEvt.CurrCount, progEvt.FileCount) + ".json"
				fptr := file.CreateFile(fnm)
				json.WriteJson(fptr, progEvt.Cache)

				progEvt.TotalSize += float64(file.Size(fnm))
				progEvt.Cache = []map[string]interface{}{}
				progEvt.CurrCount = 0
				progEvt.FileCount++
			}

		case <-progEvt.stopperChan:
			if progEvt.CurrCount > 0 {
				fnm = directory + "/" + filename(progEvt.CurrCount, progEvt.FileCount) + ".json"
				fptr := file.CreateFile(fnm)
				json.WriteJson(fptr, progEvt.Cache)

				progEvt.TotalSize += float64(file.Size(fnm))
				progEvt.Cache = []map[string]interface{}{}
				progEvt.CurrCount = 0
				progEvt.FileCount++
			}

			progress.Basic("Total %d records caputured. Wrote to %d json files of size %f MB at path \n\n%s.\n", progEvt.TotalCount, progEvt.FileCount, progEvt.TotalSize/(1024*1024), directory)

			progEvt.ShouldTerminate = true
			progEvt.EndTime = time.Now()
			progEvt.Close()

		}

		progress.Basic("Captured %d records. Wrote %d JSON files. Size of the data exported %f MB.", progEvt.TotalCount, progEvt.FileCount, progEvt.TotalSize/(1024*1024))

		if progEvt.ShouldTerminate {
			break
		}
	}
}

func NewEbpf() (*ProgramData, error) {
	eb := &ProgramData{
		EventDataChan:      make(chan *bpfEventData),
		MapDataEmitterChan: make(chan []byte),
	}

	err := eb.LoadEbpf()
	if err != nil {
		return nil, err
	}

	return eb, nil
}

func (l *Limits) defaultLimits() {
	l.RecordCount = 1000
	l.TimeLimit = 5
}

func (p *ProgramData) LoadEbpf() error {
	var err error

	//Removes memory lock limit of the ebpf program
	err = rlimit.RemoveMemlock()
	if err != nil {
		return err
	}

	//Loads ebpf objects(programs, maps)
	err = loadBpfObjects(&p.BpfObj, nil)
	if err != nil {
		return err
	}

	//Attach program to a hook
	p.BpfHook, err = link.Tracepoint("syscalls", "sys_enter_execve", p.BpfObj.EbpfExecve, nil)
	if err != nil {
		return err
	}

	//Create ringbuffer map reader
	p.BpfMapReader, err = ringbuf.NewReader(p.BpfObj.Event)
	if err != nil {
		return err
	}

	return nil
}

func (p *ProgramData) MapStart() {
	for {
		record, err := p.BpfMapReader.Read()
		if err != nil {
			continue
		}

		p.MapDataEmitterChan <- record.RawSample
	}

}

func (p *ProgramData) Start() {
	for {
		mapChan := <-p.MapDataEmitterChan

		if p.ShouldTerminate {
			break
		}

		var rec bpfEventData
		err := misc.PrettyBytes(mapChan, &rec)
		if err != nil {
			continue
		}

		p.EventDataChan <- &rec
	}
}

func (p *ProgramData) Close() {
	p.ShouldTerminate = true
	p.BpfHook.Close()
	p.BpfMapReader.Close()
	p.BpfObj.Close()
	p.Timer.Stop()
}

func filename(rc int, fc int) string {
	return misc.FormatString("%s_%d_%d", time.Now("15 04 05"), fc, rc)
}
